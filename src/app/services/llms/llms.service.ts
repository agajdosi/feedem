import { Injectable } from '@angular/core';
import { User, Post, View, React, Reaction, Comment, ReactionParentType, CommentParentType, BigFive, PlutchikEmotions, RussellCircumplex } from '../../models/game';
import { describeRecentActivity } from '../../shared/textual';
import { v4 as uuidv4 } from 'uuid';
const environment = {
  aigenburgAPI: 'https://aigenburg.lab.gajdosik.org' // -> uses prompts defined at https://phoenix.lab.gajdosik.org
  //aigenburgAPI: 'http://localhost:8888' // for local development
  // TODO: make this switch automatically based on the environment
};

@Injectable({
  providedIn: 'root'
})
export class LlmsService {

  /** Generate a new post for social network by the User. This
   * @param user - The User who is generating the post.
   * @param recentActivity - The recent activity of the User, containing recent User's posts and recent Posts under which the User has commented.
   * TODO: implement more self-reflective memory system instead of recentActivity based on linear history.
   * Define the prompts at: https://phoenix.lab.gajdosik.org
   */
  async generatePost(user: User, recentActivity: string, ftime: number): Promise<Post> {
    const body = JSON.stringify({
      prompt_identifier: "feedem_generate_post",
      prompt_variables: {
        name: user.name,
        surname: user.surname,
        gender: user.gender,
        age: String(user.age),
        bio: user.bio,
        city: user.residence.city,
        country: user.residence.country,
        occupation: user.occupation,
        traits: user.traits.join(', '),
        timestring: new Date(ftime).toISOString(),
        recent_activity: recentActivity,
        memory_string: "", // TODO: contruct memory of previous posts
        dialect: user.dialect,
      }
    });
    console.log('‚úçÔ∏è generatePost -> sending data:', body);
    const response = await fetch(`${environment.aigenburgAPI}/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }, // https://phoenix.lab.gajdosik.org/prompts/UHJvbXB0OjY=
      body: body,
    });

    const data = await response.json();
    const parsedData = typeof data === 'string' ? JSON.parse(data) : data;
    if (!parsedData?.choices?.[0]?.message?.content) {
      throw new Error('Invalid response format from API');
    }

    const post_text = parsedData.choices[0].message.content;
    console.log('‚úçÔ∏è generatePost <- response:', post_text);

    const post: Post = {
      uuid: uuidv4(),
      author: user.uuid,
      text: post_text,
      reasoning: '', // This will be filled when the post is viewed
      f_created: ftime,
      r_created: Date.now(),
    };

    return post;
  }

  /**
   * Simulate a user viewing a post and creating an opinion about it according to their identity.
   * 1. generate a _reflection text about the post, inter step for deeper reasoning
   * 2. based on the _reflection, create JSON with scores for each reaction type
   * 
   * @param post - The Post which is being viewed.
   * @param user - The User who is viewing the post.
   * @param postContext - The context of the post, including comments and reactions, generated by the utils/textual.postToText() function.
   * @returns The View object containing the reflection, rating and other information.
   */
  async viewPost(post: Post, user: User, postContext: string): Promise<View> {
    const genURL  = `${environment.aigenburgAPI}/generate`;
    // 1. REFLECT - think about the post
    const response = await fetch(genURL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ // https://phoenix.lab.gajdosik.org/prompts/UHJvbXB0OjM=
        prompt_identifier: "feedem_reflect_post",
        prompt_variables: {
          //post_text: post.text,
          post_context: postContext,
          reader_bio: user.bio,
        }
      })
    })

    const reflectionData = await response.json();
    const parsedReflection = typeof reflectionData === 'string' ? JSON.parse(reflectionData) : reflectionData;
    if (!parsedReflection?.choices?.[0]?.message?.content) {
      throw new Error('Invalid response format from API');
    }
    const reflection = parsedReflection.choices[0].message.content;
    console.log(`Got reflection on post (${post.uuid}): ${reflection}`);
    
    // 2. RATE - based on the reflection, create JSON with scores for each reaction type
    const resp = await fetch(genURL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ // https://phoenix.lab.gajdosik.org/prompts/UHJvbXB0OjQ=
        prompt_identifier: "feedem_rate_post",
        prompt_variables: {
          reflection: reflection,
        }
      })
    })

    const ratingData = await resp.json();
    const parsedRating = typeof ratingData === 'string' ? JSON.parse(ratingData) : ratingData;
    if (!parsedRating?.choices?.[0]?.message?.content) {
      throw new Error('Invalid response format from API');
    }
    const rating = parsedRating.choices[0].message.content;
    console.log(`Got rating for post (${post.uuid}): ${rating}`);
    const parsedRatingObj = JSON.parse(rating); // Parse the LLM response (expected to be JSON) from JSON to object

    const view: View = {
      uuid: uuidv4(),
      user: user.uuid,
      post: post.uuid,
      time: Date.now(),
      _reasoning: reflection,
      _rating: rating,
      joyScore: parsedRatingObj.enjoyScore,
      sadScore: parsedRatingObj.sadScore,
      stupidScore: parsedRatingObj.stupidScore,
      boringScore: parsedRatingObj.boringScore,
      reactionLikeUrge: parsedRatingObj.reactionLikeUrge,
      reactionDislikeUrge: parsedRatingObj.reactionDislikeUrge,
      reactionShittyUrge: parsedRatingObj.reactionShittyUrge,
      reactionLoveUrge: parsedRatingObj.reactionLoveUrge,
      commentUrge: parsedRatingObj.commentUrge,
      shareUrge: 0, // Not implemented
    };

    return view;
  }

  /**
   * Decide which reaction the User will make under the post they have just seen.
   * We take only the reaction type with the highest urge and ignore all others. Then weroll a random number.
   * @param view - The view of the post.
   * @returns The reaction or null if the user will not react.
   */
  decideReaction(view: View): Reaction | null {
    const max = Math.max(view.reactionLikeUrge, view.reactionDislikeUrge, view.reactionShittyUrge, view.reactionLoveUrge);
    const roll = Math.random();
    if (roll > max) {
      return null;
    }

    // if two urges are completely equal, we prefer the extremes and negations ;)
    let reactionType: React;
    if (max === view.reactionShittyUrge) reactionType = React.Shit;
    else if (max === view.reactionLoveUrge) reactionType = React.Love;
    else if (max === view.reactionLikeUrge) reactionType = React.Like;
    else if (max === view.reactionDislikeUrge) reactionType = React.Dislike;
    else {
      throw new Error('Invalid reaction type');
    }
    
    const reaction: Reaction = {
      value: reactionType,
      author: view.user,
      parent: view.post,
      parent_type: ReactionParentType.Post,
      uuid: uuidv4()
    };
    return reaction;
  }

  /**
   * Decide whether the user will comment on the post they have just seen.
   */
  async decideComment(view: View, user: User, post: Post, ftime: number): Promise<Comment | null> {
    const roll = Math.random();
    if (roll > view.commentUrge) {
      return null;
    }

    const comment = await this.generateCommentUnderPost(user, post, view, ftime);
    return comment;
  }


  /** Generate a comment by user under a post, based on the previously generated reflection and rating of the post by the user. 
   * TODO: provide info if Reaction was done by the user or not. Actually provide also info about other users reactions.
  */
  async generateCommentUnderPost(user: User, post: Post, view: View, ftime: number): Promise<Comment> {
    const genURL  = `${environment.aigenburgAPI}/generate`;
    // 1. REFLECT - think about the post
    const body = JSON.stringify({
      prompt_identifier: "feedem_generate_comment",
      prompt_variables: {
        user_bio: user.bio,
        author_name: post.author,
        author_surname: post.author,
        post_text: post.text,
        reasoning: view._reasoning,
        dialect: user.dialect,
        traits: user.traits.join(', '),
        timestring: new Date(ftime).toISOString(),
      }
    })
    console.log('üí¨ generateCommentUnderPost -> sending data:', body);
    const response = await fetch(genURL, { // https://phoenix.lab.gajdosik.org/prompts/UHJvbXB0Ojc=
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: body
    })

    const commentData = await response.json();
    console.log('Raw API Response:', commentData);
    
    const parsedComment = typeof commentData === 'string' ? JSON.parse(commentData) : commentData;
    console.log('Parsed Comment Data:', parsedComment);
    
    if (!parsedComment?.choices?.[0]?.message?.content) {
      console.error('Invalid response structure:', {
        hasChoices: !!parsedComment?.choices,
        choicesLength: parsedComment?.choices?.length,
        hasMessage: !!parsedComment?.choices?.[0]?.message,
        hasContent: !!parsedComment?.choices?.[0]?.message?.content
      });
      throw new Error('Invalid response format from API');
    }

    const comment_text = parsedComment.choices[0].message.content;
    console.log(`üí¨ generateCommentUnderPost <- response: ${comment_text}`);
    
    const comment: Comment = {
      uuid: uuidv4(),
      author: user.uuid,
      parent: post.uuid,
      parent_type: CommentParentType.Post,
      text: comment_text,
      f_created: ftime,
      r_created: Date.now(),
    };
    return comment;
  }

  // TODO: FINALIZE THIS
  async recalculateBigFive(user: User, all_users: User[], all_posts: Post[], all_comments: Comment[], all_reactions: Reaction[]): Promise<BigFive> {
    const q = 2; // old value has 2x weight
    const genURL = `${environment.aigenburgAPI}/generate`;
    const posts_context = describeRecentActivity(user, all_posts, all_users, all_comments, all_reactions);
    const body = JSON.stringify({
      prompt_identifier: "feedem_psyche_bigfive",
      prompt_variables: {
        name: user.name,
        surname: user.surname,
        gender: user.gender,
        age: String(user.age),
        bio: user.bio,
        traits: user.traits.join(', '),
        posts_context: posts_context,
      }
    })

    const response = await fetch(genURL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: body,
    });

    const data = await response.json();
    const parsedData = typeof data === 'string' ? JSON.parse(data) : data;
    if (!parsedData?.choices?.[0]?.message?.content) {
      throw new Error('Invalid response format from API');
    }

    const newBigFive = JSON.parse(parsedData.choices[0].message.content) as BigFive;
    let finalBigFive: BigFive = {
      openness: 0,
      conscientiousness: 0,
      extraversion: 0,
      agreeableness: 0,
      neuroticism: 0
    };
    const traits: (keyof BigFive)[] = [
      'openness',
      'conscientiousness',
      'extraversion',
      'agreeableness',
      'neuroticism'
    ];
    for (const trait of traits) {
      if (newBigFive[trait] !== undefined) {
        const clampedValue = Math.max(0, Math.min(1, newBigFive[trait]));
        finalBigFive[trait] = (user.big_five[trait] * q + clampedValue) / (q + 1);
      } else {
        finalBigFive[trait] = user.big_five[trait];
      }
    }
    return finalBigFive;
  }


  async recalculatePlutchikEmotions(user: User, all_users: User[], all_posts: Post[], all_comments: Comment[], all_reactions: Reaction[]): Promise<PlutchikEmotions> {
    const q = 2; // old value has 2x weight
    const genURL = `${environment.aigenburgAPI}/generate`;
    const posts_context = describeRecentActivity(user, all_posts, all_users, all_comments, all_reactions);
    const body = JSON.stringify({
      prompt_identifier: "feedem_psyche_plutchik",
      prompt_variables: {
        name: user.name,
        surname: user.surname,
        gender: user.gender,
        age: String(user.age),
        bio: user.bio,
        traits: user.traits.join(', '),
        posts_context: posts_context,
      }
    })
    const response = await fetch(genURL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: body,
    })
    const data = await response.json();
    const parsedData = typeof data === 'string' ? JSON.parse(data) : data;
    if (!parsedData?.choices?.[0]?.message?.content) {
      throw new Error('Invalid response format from API');
    }

    const newPlutchik = JSON.parse(parsedData.choices[0].message.content) as PlutchikEmotions;
    let finalPlutchik: PlutchikEmotions = {
      joy_sadness: 0,
      anger_fear: 0,
      trust_disgust: 0,
      surprise_anticipation: 0
    };
    const traits: (keyof PlutchikEmotions)[] = [
      'joy_sadness',
      'anger_fear',
      'trust_disgust',
      'surprise_anticipation'
    ];
    for (const trait of traits) {
      if (newPlutchik[trait] !== undefined) {
        const clampedValue = Math.max(-1, Math.min(1, newPlutchik[trait]));
        finalPlutchik[trait] = (user.plutchik[trait] * q + clampedValue) / (q + 1);
      } else {
        finalPlutchik[trait] = user.plutchik[trait];
      }
    }
    return finalPlutchik;
  }

  async recalculateRussellCircumplex(user: User, all_users: User[], all_posts: Post[], all_comments: Comment[], all_reactions: Reaction[]): Promise<RussellCircumplex> {
    const q = 2; // old value has 2x weight
    const genURL = `${environment.aigenburgAPI}/generate`;
    const posts_context = describeRecentActivity(user, all_posts, all_users, all_comments, all_reactions);
    const body = JSON.stringify({
      prompt_identifier: "feedem_psyche_russell",
      prompt_variables: {
        name: user.name,
        surname: user.surname,
        gender: user.gender,
        age: String(user.age),
        bio: user.bio,
        traits: user.traits.join(', '),
        posts_context: posts_context,
      }
    })

    const response = await fetch(genURL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: body,
    })

    const data = await response.json();
    const parsedData = typeof data === 'string' ? JSON.parse(data) : data;
    if (!parsedData?.choices?.[0]?.message?.content) {
      throw new Error('Invalid response format from API');
    }

    const newRussell = JSON.parse(parsedData.choices[0].message.content) as RussellCircumplex;
    let finalRussell: RussellCircumplex = {
      valence: 0,
      arousal: 0
    };
    const traits: (keyof RussellCircumplex)[] = [
      'valence',
      'arousal'
    ];
    for (const trait of traits) {
      if (newRussell[trait] !== undefined) {
        const clampedValue = Math.max(-1, Math.min(1, newRussell[trait]));
        finalRussell[trait] = (user.russell[trait] * q + clampedValue) / (q + 1);
      } else {
        finalRussell[trait] = user.russell[trait];
      }
    }
    return finalRussell;
  }

  /** TOTAL DUMMY!
   * TODO: implement in v2.
   */
  async generateCommentUnderComment(user: User, comment: Comment, view: View, ftime: number): Promise<Comment> {
    const c: Comment = {
      uuid: uuidv4(),
      author: user.uuid,
      parent: comment.uuid,
      parent_type: CommentParentType.Comment,
      text: 'This is a dummy comment',
      f_created: Date.now(),
      r_created: Date.now(),
    };
    return c;
  }
}
